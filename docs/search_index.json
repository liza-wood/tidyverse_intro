[["index.html", "Tidyverse: Data wrangling &amp; visualization Overview 0.1 Introduction 0.2 Acknowledgements", " Tidyverse: Data wrangling &amp; visualization Liza Wood 2023-03-27 Overview 0.1 Introduction This tutorial is an introduction to data wrangling and visualization using functions from the tidyverse. It uses data from the Palmer Station’s Long Term Ecological Research program based in Antarctica, including the palmerpenguins and weather monitoring data. These lessons walk through key steps in the data wrangling phase, including subsetting data, creating new variables using conditional statements, summarizing data at aggregate levels, working with dates, joining together multiple data frames, and reshaping data. This lesson also provides an introduction to combining data wrangling with visualization. Prerequisites Installation of R and RStudio General knowledge of R’s base functionality (math, naming objects) (note: you can familiarize yourself with R’s base functionality and RStudio’s layout here) Figure 0.1: Artwork by @allison_horst 0.2 Acknowledgements This site was developed based on material from UC Davis’s R-DAVIS course, which draws heavily on Carpenties R Carpentries lessons. Additionally, artwork is from Allison Horst (@allison_horst) and website styling was also based on the designs from the Palmer Penguins package webpage "],["introduction-to-the-tidyverse.html", "1 Introduction to the Tidyverse 1.1 What is the tidyverse? 1.2 Installing and loading in", " 1 Introduction to the Tidyverse 1.1 What is the tidyverse? The tidyverse is self-described as ‘an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures’. When you install the tidyverse package, you install a suite of 9 tidy-related packages, all of which are designed to help you work with data, from cleaning and manipulation to plotting and modelling. Figure 0.1: Artwork by @allison_horst They are increasingly popular, have large user bases, and are generally very well-documented. You can install the core set of tidyverse packages with the install.packages() function: 1.2 Installing and loading in install.packages(&#39;tidyverse&#39;) Once you install the package, read it into your library for our session today (note: you only have to install packages once, but you must load the packages you are using into your library for ever R ‘session’). library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.0 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.1 ✔ tibble 3.1.8 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the ]8;;http://conflicted.r-lib.org/conflicted package]8;; to force all conflicts to become errors "],["data.html", "2 Data 2.1 Palmer Station penguins 2.2 Palmer Station weather", " 2 Data 2.1 Palmer Station penguins The Palmer Station penguins data is a tidy dataset related to three species of Antarctic penguins from Horst, Hill, and Gorman (2020)1. The data contains size measurements for and female adult foraging Adélie, Chinstrap, and Gentoo penguins observed on islands in the Palmer Archipelago near Palmer Station, Antarctica between 2007-2009. Data were collected and made available by Dr. Kristen Gorman and the Palmer Station Long Term Ecological Research (LTER) Program. You can read more about the package here. Let’s start by installing the package in one of two ways: # Install from CRAN install.packages(&#39;palmerpenguins&#39;) # Or install directory from the github repository remotes::install_github(&quot;allisonhorst/palmerpenguins&quot;) Now we can load in the package library, which stores the penguins dataset. library(palmerpenguins) head(penguins) ## # A tibble: 6 × 8 ## species island bill_length_mm bill_depth_mm flipper_l…¹ body_…² sex year ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 3750 male 2007 ## 2 Adelie Torgersen 39.5 17.4 186 3800 fema… 2007 ## 3 Adelie Torgersen 40.3 18 195 3250 fema… 2007 ## 4 Adelie Torgersen NA NA NA NA &lt;NA&gt; 2007 ## 5 Adelie Torgersen 36.7 19.3 193 3450 fema… 2007 ## 6 Adelie Torgersen 39.3 20.6 190 3650 male 2007 ## # … with abbreviated variable names ¹​flipper_length_mm, ²​body_mass_g Learn more about each variable in the documentation ?penguins Let’s take a look at its structure: str(penguins) ## tibble [344 × 8] (S3: tbl_df/tbl/data.frame) ## $ species : Factor w/ 3 levels &quot;Adelie&quot;,&quot;Chinstrap&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ island : Factor w/ 3 levels &quot;Biscoe&quot;,&quot;Dream&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ bill_length_mm : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ... ## $ bill_depth_mm : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ... ## $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ... ## $ body_mass_g : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ... ## $ sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 1 1 NA 1 2 1 2 NA NA ... ## $ year : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ... 2.2 Palmer Station weather To practice data wrangling skills, this tutorial will also use another data set from the Antarctic LTER Program – the ‘Daily averaged weather timeseries at Palmer Station, Antarctica’2, which includes various weather metrics measured between 1989-2019. We’ll read in these data directly from online and name the data frame weather. weather &lt;- read.csv(&quot;https://pasta.lternet.edu/package/data/eml/knb-lter-pal/28/8/375b34051b162d84516ec2d02f864675&quot;) These data have been made available through the Environmental Data Initiative and more information can be found here Let’s take a look at the data’s structure: str(weather) ## &#39;data.frame&#39;: 10674 obs. of 24 variables: ## $ Date : chr &quot;1989-04-01&quot; &quot;1989-04-02&quot; &quot;1989-04-03&quot; &quot;1989-04-04&quot; ... ## $ Temperature.High..C. : num 2.8 1.1 -0.6 1.1 -0.6 2.5 -1.4 -0.8 -1 -1.5 ... ## $ Temperature.Low..C. : num -1 -2.7 -3.5 -4.4 -2.9 -3.1 -3.2 -4.5 -4 -3.8 ... ## $ Temperature.Average..C. : num 0.9 -0.8 -2.05 -1.65 -1.75 -0.3 -2.3 -2.65 -2.5 -2.65 ... ## $ Sea.Surface.Temperature..C. : num NA NA NA NA NA NA NA NA NA NA ... ## $ Sea.Ice..WMO.Code. : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Pressure.High..mbar. : num 1004 998 998 1002 1002 ... ## $ Pressure.Low..mbar. : num 998 995 995 998 997 ... ## $ Pressure.Average..mbar. : num 1001 996 997 1000 1000 ... ## $ Windspeed.Peak : int 18 24 13 14 14 15 16 39 27 16 ... ## $ Windspeed.5.Sec.Peak : num NA NA NA NA NA NA NA NA NA NA ... ## $ Windspeed.2.Min.Peak : int NA NA NA NA NA NA NA NA NA NA ... ## $ Windspeed.Average : num 4 9 8 6 4 4 8 14 11 6 ... ## $ Wind.Peak.Direction..True...º. : int 110 30 60 210 230 180 40 120 50 60 ... ## $ Wind.Peak.Direction..º. : int NA NA NA NA NA NA NA NA NA NA ... ## $ Wind.5.Sec.Peak.Direction...º. : int NA NA NA NA NA NA NA NA NA NA ... ## $ Wind.2.Min.Peak.Direction...º. : int NA NA NA NA NA NA NA NA NA NA ... ## $ Wind.Direction.Prevailing : chr &quot;SW&quot; &quot;NE&quot; &quot;NE&quot; &quot;NW&quot; ... ## $ Rainfall..mm. : num 0 0 0 0 0 0 1 0 0 -998 ... ## $ Precipitation.Snow..cm. : num 0 0 0 0 0 0 -998 0 0 -998 ... ## $ Depth.at.Snowstake..cm. : num NA NA NA NA NA NA NA NA NA NA ... ## $ Cloud.Cover : int 4 2 5 5 10 2 9 5 0 10 ... ## $ Data.flag...Temperature.Average: chr &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; ... ## $ Data.flag...Pressure.Average : chr &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; ... Together this tutorial uses data collected from penguins across three islands in the Palmer archipelago and weather sensing technology at the US Palmer Station. Figure 2.1: Artwork by @allison_horst Figure 2.2: Palmer archipelago, image from Gorman et al. 2014 Figure 1 Horst AM, Hill AP, Gorman KB (2020). palmerpenguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpenguins/. doi: 10.5281/zenodo.3960218.↩︎ Palmer Station Antarctica LTER and P. Information Manager. 2019. Daily averaged weather timeseries (air temperature, pressure, wind speed, wind direction, precipitation, sky cover) at Palmer Station, Antarctica combining manual observations (1989 - Dec 12, 2003) and PALMOS automatic weather station measurements (Dec 13, 2003 - March 2019). ver 8. Environmental Data Initiative. https://doi.org/10.6073/pasta/cddd3985350334b876cd7d6d1a5bc7bf (Accessed 2023-03-27).↩︎ "],["data-wrangling-basics.html", "3 Data wrangling basics 3.1 Outline 3.2 Reducing data dimensionality 3.3 Combining multiple steps 3.4 Creating new variables", " 3 Data wrangling basics 3.1 Outline Reducing data dimensionality: select: Name the columns to keep, separated by a comma. Using select will reduce the number of columns in your data frame filter: Set conditions by which you want to filter (keep) some of the data. Using the filter function will reduce the number of rows in your data frame is.na(): Insert a column name to get a logical vector indicated whether each value in that row has an NA value Combining multiple steps %&gt;%: Link together multiple steps by ‘piping’ the output of one line of code into the next Creating new variables Summary tables group_by: Set a column (or columns) by which you want to perform a summarizing function on. Using this function does apparently nothing on its own, but is powerful when paired with summarize (or mutate) summarize: Create a new variable by performing a variety of summary/transformative functions on an existing column (or set of columns). When paired with group_by, data is reduced to a summary table New columns mutate: Create a new column by assigning a value (transformed or otherwise) case_when: Pair with mutate to create a new variable that is based on &gt;1 conditions, typically for creating categorical variables 3.2 Reducing data dimensionality The functions, select and filter, are what you can use to reduce dimensionality of your data frame. That means reducing the number of column (with select) and/or the number of rows (with filter). To use select, name the columns to keep, separated by a comma. For example, let’s select the species, year, sex, and body mass. # Hint: check your column names first colnames(penguins) ## [1] &quot;species&quot; &quot;island&quot; &quot;bill_length_mm&quot; ## [4] &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; &quot;body_mass_g&quot; ## [7] &quot;sex&quot; &quot;year&quot; # select species, year, sex, and body mass penguins_selected &lt;- select(penguins, species, year, sex, body_mass_g) # Take a look at the &#39;dimensions&#39; with dim() dim(penguins_selected) ## [1] 344 4 The select columns can also be used to remove columns (unselect) rather than select by using the - operator. For example, we may want to remove only two columns, island and year: # Un-select the island and year columns by using -. penguins_unselected &lt;- select(penguins, -island, -year) # Take a look at the &#39;dimensions&#39; with dim() dim(penguins_unselected) ## [1] 344 6 New, let’s filter the data based on a certain condition. Creating ‘conditions’ in R means writing logical statements with a response that will be either TRUE or FALSE. To write conditions we can use comparative operators, which give a logical output: Comparative Operator Name Example == Equal x == y != Not equal x != y &gt; Greater than x &gt; y &lt; Less than x &lt; y &gt;= Greater than or equal to x &gt;= y &lt;= Less than or equal to x &lt;= y head(penguins$year == 2007, n = 75) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [25] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [37] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [49] TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [73] FALSE FALSE FALSE The filter function evaluates those conditions, and keeps only the rows for which the value os TRUE. For example, let’s filter observations so that we only keep those from the year 2007. penguins_filtered &lt;- filter(penguins, year == 2007) dim(penguins_filtered) ## [1] 110 8 There are other functions to evaluate columns and get a T/F output. An important one is is.na(). This function evaluates a column and reports back a TRUE value when there is an NA in that column’s row. For example, we can use the head() function to look at the top 6 values of the sex column, and see that there is an NA in the fourth row. head(penguins$sex, n = 75) ## [1] male female female &lt;NA&gt; female male female male &lt;NA&gt; &lt;NA&gt; ## [11] &lt;NA&gt; &lt;NA&gt; female male male female female male female male ## [21] female male female male male female male female female male ## [31] female male female male female male male female female male ## [41] female male female male female male male &lt;NA&gt; female male ## [51] female male female male female male female male female male ## [61] female male female male female male female male female male ## [71] female male female male female ## Levels: female male The is.na function evaluates the whole column and gives us TRUES whenever it sees an NA. Not surprisingly, we see a TRUE in the fourth observation. head(is.na(penguins$sex), n = 75) ## [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [73] FALSE FALSE FALSE Since is.na() gives us a T/F vector, it is already a good candidate for putting right into filter. Below we are asking the filter function to keep only the observations that have an NA in the sex column. penguins_filtered_nas &lt;- filter(penguins, is.na(sex)) dim(penguins_filtered_nas) ## [1] 11 8 To do the reverse, i.e. keep only the observations that do NOT have an NA in the sex column, we can use the ! sign to denote ‘not’ and reverse the T/F. penguins_filtered_nonas &lt;- filter(penguins, !is.na(sex)) dim(penguins_filtered_nonas) ## [1] 333 8 You can combined multiple conditions using logical operators: Logical Operator Name Example &amp; AND x == 2 &amp; y == 10 | OR x == 2 | y == 10 3.3 Combining multiple steps There are several ways to combine steps in coding. You can perform one function at a time and save intermediate objects as you work, you can ‘nest’ functions, or you can use ‘pipes’ (%&gt;%). So for example, if you wanted to select the species, sex, bill length, and bill depth, and filter data so to only keep data ‘Adelie’ penguins, with no NAs in the sex column, these first two options would look as follows: # Multiple steps with intermediate objects penguins_step1 &lt;- select(penguins, species, sex, bill_length_mm, bill_depth_mm) penguins_step2 &lt;- filter(penguins_step1, species == &#39;Adelie&#39; &amp; !is.na(sex)) summary(penguins_step2) ## species sex bill_length_mm bill_depth_mm ## Adelie :146 female:73 Min. :32.10 Min. :15.50 ## Chinstrap: 0 male :73 1st Qu.:36.73 1st Qu.:17.50 ## Gentoo : 0 Median :38.85 Median :18.40 ## Mean :38.82 Mean :18.35 ## 3rd Qu.:40.77 3rd Qu.:19.00 ## Max. :46.00 Max. :21.50 # Multiple steps with nested functions penguins_nested &lt;- filter(select(penguins, species, sex, bill_length_mm, bill_depth_mm), species == &#39;Adelie&#39; &amp; !is.na(sex)) summary(penguins_nested) ## species sex bill_length_mm bill_depth_mm ## Adelie :146 female:73 Min. :32.10 Min. :15.50 ## Chinstrap: 0 male :73 1st Qu.:36.73 1st Qu.:17.50 ## Gentoo : 0 Median :38.85 Median :18.40 ## Mean :38.82 Mean :18.35 ## 3rd Qu.:40.77 3rd Qu.:19.00 ## Max. :46.00 Max. :21.50 The third option is pipes. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same data set. Pipes in R look like %&gt;% and are made available via the magrittr package, installed automatically with the tidyverse. If you use RStudio, you can type the pipe with Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac. # Multiple steps with pipes penguins_piped &lt;- penguins %&gt;% select(species, sex, bill_length_mm, bill_depth_mm) %&gt;% filter(species == &#39;Adelie&#39; &amp; !is.na(sex)) summary(penguins_piped) ## species sex bill_length_mm bill_depth_mm ## Adelie :146 female:73 Min. :32.10 Min. :15.50 ## Chinstrap: 0 male :73 1st Qu.:36.73 1st Qu.:17.50 ## Gentoo : 0 Median :38.85 Median :18.40 ## Mean :38.82 Mean :18.35 ## 3rd Qu.:40.77 3rd Qu.:19.00 ## Max. :46.00 Max. :21.50 We will use the piping approach, as it helps make a smoother workflow for other wrangling functions we’ll use. 3.3.1 Check in challenge Use pipes to select only the columns for species, sex, bill_length_mm, and body_mass_g, and filter out where sex is missing and body_mass_g is greater than 3500. Name this new data frame ‘filter_challenge’ and look at a summary of it to check your work. Check your answer filter_challenge &lt;- penguins %&gt;% select(species, sex, bill_length_mm, body_mass_g) %&gt;% filter(is.na(sex) &amp; body_mass_g &gt; 3500) str(filter_challenge) ## tibble [6 × 4] (S3: tbl_df/tbl/data.frame) ## $ species : Factor w/ 3 levels &quot;Adelie&quot;,&quot;Chinstrap&quot;,..: 1 1 3 3 3 3 ## $ sex : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: NA NA NA NA NA NA ## $ bill_length_mm: num [1:6] 42 37.8 44.5 46.2 47.3 44.5 ## $ body_mass_g : int [1:6] 4250 3700 4100 4650 4725 4875 3.4 Creating new variables 3.4.1 New columns We may often want to make a new column with some updated or transformed value. We can use the mutate function for this, in which you can assign the new column name and its value. The idea is generally mutate(data, new_column_name = value). For example, if we wanted to calculate a new value, the ratio of bill length to bill depth, we could do the following # Mutate to create a new column; use penguins_piped so our output is # easier to view mutate(penguins_piped, bill_ratio = bill_length_mm / bill_depth_mm) ## # A tibble: 146 × 5 ## species sex bill_length_mm bill_depth_mm bill_ratio ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie male 39.1 18.7 2.09 ## 2 Adelie female 39.5 17.4 2.27 ## 3 Adelie female 40.3 18 2.24 ## 4 Adelie female 36.7 19.3 1.90 ## 5 Adelie male 39.3 20.6 1.91 ## 6 Adelie female 38.9 17.8 2.19 ## 7 Adelie male 39.2 19.6 2 ## 8 Adelie female 41.1 17.6 2.34 ## 9 Adelie male 38.6 21.2 1.82 ## 10 Adelie male 34.6 21.1 1.64 ## # … with 136 more rows Note that in order to save the column in the data frame, we must assign it as a new data frame object. The output of mutate is not just a new column on its own, but the whole data frame with the new column appended. So far we have not overwritten in, and we can see that bill_depth_cm is not in our penguins data frame colnames(penguins_piped) ## [1] &quot;species&quot; &quot;sex&quot; &quot;bill_length_mm&quot; &quot;bill_depth_mm&quot; Only once we assign it do we have a data frame now with the new column appended penguins_newcolumn &lt;- mutate(penguins_piped, bill_ratio = bill_length_mm / bill_depth_mm) colnames(penguins_newcolumn) ## [1] &quot;species&quot; &quot;sex&quot; &quot;bill_length_mm&quot; &quot;bill_depth_mm&quot; ## [5] &quot;bill_ratio&quot; In addition to the mathematical transformations we just tried, we may want to create new, discrete categories with our data. For example, let’s categorize bill length into discrete size groups, small, summary(penguins_newcolumn$bill_ratio) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.640 2.013 2.138 2.121 2.239 2.450 All values are greater than 1, so all bill lengths are greater than depths. Still, lower ratio values mean that the bill depth is large relative to its length (deep bills) and higher values mean that bill depth is small relative to its length (shallow bills). Let’s say we wanted to use these bill lengths ratios to group penguins into one of three groups: ‘deep’ ‘average’ and ‘shallow’. Figure 3.1: Artwork by @allison_horst The case_when functions, combined with mutate, lets us set multiple conditions and resulting categories. This function uses a series of two-sided formulas where the left-hand side determines describes the condition, and the right supplies the result. The final condition should always be TRUE, meaning that when the previous conditions have not been met, assign the last value. Using these functions we can create a depth ratio category variable: penguins_newcolumn &lt;- penguins_newcolumn %&gt;% mutate(bill_depth_cat = case_when( # Using the 1st Q as cutoff bill_ratio &lt;= 2.013 ~ &#39;deep&#39;, # Between 1st and 2rd Q bill_ratio &gt; 2.013 &amp; bill_ratio &lt;= 2.239 ~ &#39;average&#39;, T ~ &#39;shallow&#39; )) head(penguins_newcolumn$bill_depth_cat, n = 75) ## [1] &quot;average&quot; &quot;shallow&quot; &quot;average&quot; &quot;deep&quot; &quot;deep&quot; &quot;average&quot; &quot;deep&quot; ## [8] &quot;shallow&quot; &quot;deep&quot; &quot;deep&quot; &quot;average&quot; &quot;average&quot; &quot;average&quot; &quot;deep&quot; ## [15] &quot;average&quot; &quot;average&quot; &quot;average&quot; &quot;deep&quot; &quot;average&quot; &quot;shallow&quot; &quot;deep&quot; ## [22] &quot;average&quot; &quot;shallow&quot; &quot;average&quot; &quot;average&quot; &quot;shallow&quot; &quot;average&quot; &quot;average&quot; ## [29] &quot;average&quot; &quot;average&quot; &quot;deep&quot; &quot;deep&quot; &quot;shallow&quot; &quot;deep&quot; &quot;average&quot; ## [36] &quot;average&quot; &quot;average&quot; &quot;deep&quot; &quot;average&quot; &quot;average&quot; &quot;average&quot; &quot;average&quot; ## [43] &quot;deep&quot; &quot;deep&quot; &quot;average&quot; &quot;average&quot; &quot;deep&quot; &quot;average&quot; &quot;deep&quot; ## [50] &quot;average&quot; &quot;average&quot; &quot;average&quot; &quot;average&quot; &quot;deep&quot; &quot;average&quot; &quot;deep&quot; ## [57] &quot;average&quot; &quot;shallow&quot; &quot;average&quot; &quot;shallow&quot; &quot;average&quot; &quot;average&quot; &quot;average&quot; ## [64] &quot;average&quot; &quot;deep&quot; &quot;average&quot; &quot;shallow&quot; &quot;shallow&quot; &quot;average&quot; &quot;shallow&quot; ## [71] &quot;shallow&quot; &quot;deep&quot; &quot;shallow&quot; &quot;average&quot; &quot;deep&quot; A note: Always be cautious about what might be left out when naming the conditions. In the previous example, we assumes that everything left after the first two conditions would be shallow. To be on the safe side, I often set every condition and leave the last condition either an error notice, or NA, so that I can check my conditions. penguins_newcolumn &lt;- penguins_newcolumn %&gt;% mutate(bill_depth_cat = case_when( # Using the 1st Q as cutoff bill_ratio &lt;= 2.013 ~ &#39;deep&#39;, # Between 1st and 2rd Q bill_ratio &gt; 2.013 &amp; bill_ratio &lt;= 2.239 ~ &#39;average&#39;, bill_ratio &gt;= 2.239 ~ &#39;shallow&#39;, T ~ &#39;error&#39; )) 3.4.2 Summary tables Often we want to aggregate data at certain levels to better understand differences across groups. For instance, does flipper length differ by species? Does body mass change between years? We can combined group_by and summarize to help answer that. group_by sets a column (or columns) by which you want to perform a summarizing function on, then summarize creates a new variable by performing a variety of summary/transformative functions on an existing column. First, we can use sumamrize on its own, without any grouping, to get a single summary about the data frame. For example, if we want to know the mean body mass: # calculate the mean body mass for the whole data frame summarize(penguins, mean_body_mass_g = mean(flipper_length_mm)) ## # A tibble: 1 × 1 ## mean_body_mass_g ## &lt;dbl&gt; ## 1 NA If the result is NA, be sure to include the ‘na.rm = T’ argument to tell the function to ‘remove NAs’ before calculating: # set na.rm = T summarize(penguins, mean_flipper_length_mm = mean(flipper_length_mm, na.rm = T)) ## # A tibble: 1 × 1 ## mean_flipper_length_mm ## &lt;dbl&gt; ## 1 201. But if we want to know the mean flipper length across certain grouping variables, such as sex, we want to combine summarize with group_by. penguins %&gt;% group_by(species) %&gt;% summarize(mean_flipper_length_mm = mean(flipper_length_mm, na.rm = T)) ## # A tibble: 3 × 2 ## species mean_flipper_length_mm ## &lt;fct&gt; &lt;dbl&gt; ## 1 Adelie 190. ## 2 Chinstrap 196. ## 3 Gentoo 217. We group_by multiple columns at once, AND summarize can create several new summary variables within the same summarize function, just separating by a comma in both cases. For instance, we can group by species and sex, and generate two summary variables of mean and standard deviation flipper length: penguins %&gt;% group_by(species,sex) %&gt;% summarize(mean_flipper_length_mm = mean(flipper_length_mm, na.rm = T), sd_flipper_length_mm = sd(flipper_length_mm, na.rm = T)) ## `summarise()` has grouped output by &#39;species&#39;. You can override using the ## `.groups` argument. ## # A tibble: 8 × 4 ## # Groups: species [3] ## species sex mean_flipper_length_mm sd_flipper_length_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie female 188. 5.60 ## 2 Adelie male 192. 6.60 ## 3 Adelie &lt;NA&gt; 186. 6.11 ## 4 Chinstrap female 192. 5.75 ## 5 Chinstrap male 200. 5.98 ## 6 Gentoo female 213. 3.90 ## 7 Gentoo male 222. 5.67 ## 8 Gentoo &lt;NA&gt; 216. 1.26 3.4.3 Check in challenge Calculate the mean and standard deviation for each year-sex combination. Before calculating those summaries, remove the observations where there is no data for penguin sex. Name this new summary table ‘summary_challenge’. What is the mean and standard deviation of the body mass for male penguins in 2008? Check your answer summary_challenge &lt;- penguins %&gt;% filter(!is.na(sex)) %&gt;% group_by(year,sex) %&gt;% summarize(mean_body_mass_g = mean(body_mass_g, na.rm = T), sd_body_mass_g = sd(body_mass_g, na.rm = T)) ## `summarise()` has grouped output by &#39;year&#39;. You can override using the ## `.groups` argument. summary_challenge ## # A tibble: 6 × 4 ## # Groups: year [3] ## year sex mean_body_mass_g sd_body_mass_g ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2007 female 3821. 610. ## 2 2007 male 4479. 833. ## 3 2008 female 3888. 680. ## 4 2008 male 4632. 722. ## 5 2009 female 3874. 709. ## 6 2009 male 4521. 813. # mean: 4632.456 sd: 722.0687 "],["data-wrangling-beyond-basics.html", "4 Data wrangling: beyond basics 4.1 Outline 4.2 Manipulating date variables 4.3 Joining multiple data frames 4.4 Working with text", " 4 Data wrangling: beyond basics 4.1 Outline Manipulating date variables lubrdiate package: Use date format functions (e.g. ymd) to specify date data formats Joining multiple data frames _join series: Combine two data frames by one or more shared columns. Specify with kind of join(full_, left_, etc.) to determine which observations are kept/dropped. Reshaping (lengthening/widening) data pivot_longer pivot_wider Working with text to separate/combine columns separate: paste: 4.2 Manipulating date variables Remember the weather data we loaded in at the start. We have weather data from the Palmer Station in Antarctica from 1989 - 2019. These data are available for each day str(weather) ## &#39;data.frame&#39;: 10674 obs. of 24 variables: ## $ Date : chr &quot;1989-04-01&quot; &quot;1989-04-02&quot; &quot;1989-04-03&quot; &quot;1989-04-04&quot; ... ## $ Temperature.High..C. : num 2.8 1.1 -0.6 1.1 -0.6 2.5 -1.4 -0.8 -1 -1.5 ... ## $ Temperature.Low..C. : num -1 -2.7 -3.5 -4.4 -2.9 -3.1 -3.2 -4.5 -4 -3.8 ... ## $ Temperature.Average..C. : num 0.9 -0.8 -2.05 -1.65 -1.75 -0.3 -2.3 -2.65 -2.5 -2.65 ... ## $ Sea.Surface.Temperature..C. : num NA NA NA NA NA NA NA NA NA NA ... ## $ Sea.Ice..WMO.Code. : chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Pressure.High..mbar. : num 1004 998 998 1002 1002 ... ## $ Pressure.Low..mbar. : num 998 995 995 998 997 ... ## $ Pressure.Average..mbar. : num 1001 996 997 1000 1000 ... ## $ Windspeed.Peak : int 18 24 13 14 14 15 16 39 27 16 ... ## $ Windspeed.5.Sec.Peak : num NA NA NA NA NA NA NA NA NA NA ... ## $ Windspeed.2.Min.Peak : int NA NA NA NA NA NA NA NA NA NA ... ## $ Windspeed.Average : num 4 9 8 6 4 4 8 14 11 6 ... ## $ Wind.Peak.Direction..True...º. : int 110 30 60 210 230 180 40 120 50 60 ... ## $ Wind.Peak.Direction..º. : int NA NA NA NA NA NA NA NA NA NA ... ## $ Wind.5.Sec.Peak.Direction...º. : int NA NA NA NA NA NA NA NA NA NA ... ## $ Wind.2.Min.Peak.Direction...º. : int NA NA NA NA NA NA NA NA NA NA ... ## $ Wind.Direction.Prevailing : chr &quot;SW&quot; &quot;NE&quot; &quot;NE&quot; &quot;NW&quot; ... ## $ Rainfall..mm. : num 0 0 0 0 0 0 1 0 0 -998 ... ## $ Precipitation.Snow..cm. : num 0 0 0 0 0 0 -998 0 0 -998 ... ## $ Depth.at.Snowstake..cm. : num NA NA NA NA NA NA NA NA NA NA ... ## $ Cloud.Cover : int 4 2 5 5 10 2 9 5 0 10 ... ## $ Data.flag...Temperature.Average: chr &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; ... ## $ Data.flag...Pressure.Average : chr &quot;C&quot; &quot;C&quot; &quot;C&quot; &quot;C&quot; ... However, the structure of the data above indicate that the first variable, Date, is a ‘character’. This means that R is not reading these dates as numbers, and so we cannot manipulate them any further (e.g. extracting certain years). head(weather$Date) ## [1] &quot;1989-04-01&quot; &quot;1989-04-02&quot; &quot;1989-04-03&quot; &quot;1989-04-04&quot; &quot;1989-04-05&quot; ## [6] &quot;1989-04-06&quot; class(weather$Date) ## [1] &quot;character&quot; We want to use the lubridate package (loaded in when we load in tidyverse) to convert these variables into dates and create a column for the year. head(ymd(weather$Date), n = 75) ## [1] &quot;1989-04-01&quot; &quot;1989-04-02&quot; &quot;1989-04-03&quot; &quot;1989-04-04&quot; &quot;1989-04-05&quot; ## [6] &quot;1989-04-06&quot; &quot;1989-04-07&quot; &quot;1989-04-08&quot; &quot;1989-04-09&quot; &quot;1989-04-10&quot; ## [11] &quot;1989-04-11&quot; &quot;1989-04-12&quot; &quot;1989-04-13&quot; &quot;1989-04-14&quot; &quot;1989-04-15&quot; ## [16] &quot;1989-04-16&quot; &quot;1989-04-17&quot; &quot;1989-04-18&quot; &quot;1989-04-19&quot; &quot;1989-04-20&quot; ## [21] &quot;1989-04-21&quot; &quot;1989-04-22&quot; &quot;1989-04-23&quot; &quot;1989-04-24&quot; &quot;1989-04-25&quot; ## [26] &quot;1989-04-26&quot; &quot;1989-04-27&quot; &quot;1989-04-28&quot; &quot;1989-04-29&quot; &quot;1989-04-30&quot; ## [31] &quot;1989-05-01&quot; &quot;1989-05-02&quot; &quot;1989-05-03&quot; &quot;1989-05-04&quot; &quot;1989-05-05&quot; ## [36] &quot;1989-05-06&quot; &quot;1989-05-07&quot; &quot;1989-05-08&quot; &quot;1989-05-09&quot; &quot;1989-05-10&quot; ## [41] &quot;1989-05-11&quot; &quot;1989-05-12&quot; &quot;1989-05-13&quot; &quot;1989-05-14&quot; &quot;1989-05-15&quot; ## [46] &quot;1989-05-16&quot; &quot;1989-05-17&quot; &quot;1989-05-18&quot; &quot;1989-05-19&quot; &quot;1989-05-20&quot; ## [51] &quot;1989-05-21&quot; &quot;1989-05-22&quot; &quot;1989-05-23&quot; &quot;1989-05-24&quot; &quot;1989-05-25&quot; ## [56] &quot;1989-05-26&quot; &quot;1989-05-27&quot; &quot;1989-05-28&quot; &quot;1989-05-29&quot; &quot;1989-05-30&quot; ## [61] &quot;1989-05-31&quot; &quot;1989-06-01&quot; &quot;1989-06-02&quot; &quot;1989-06-03&quot; &quot;1989-06-04&quot; ## [66] &quot;1989-06-05&quot; &quot;1989-06-06&quot; &quot;1989-06-07&quot; &quot;1989-06-08&quot; &quot;1989-06-09&quot; ## [71] &quot;1989-06-10&quot; &quot;1989-06-11&quot; &quot;1989-06-12&quot; &quot;1989-06-13&quot; &quot;1989-06-14&quot; Use the mutate function to overwrite this variable in the weather data frame weather &lt;- mutate(weather, Date = ymd(Date)) head(weather$Date) ## [1] &quot;1989-04-01&quot; &quot;1989-04-02&quot; &quot;1989-04-03&quot; &quot;1989-04-04&quot; &quot;1989-04-05&quot; ## [6] &quot;1989-04-06&quot; class(weather$Date) ## [1] &quot;Date&quot; Now that R recognizes these as dates, we can extract certain date-related features, such as the year, month, and day. The lubridate package has functions conveniently named year(), month(), day() that can be used with a date argument, and that element of the date will be extracted. For example: head(year(weather$Date), n = 75) ## [1] 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 ## [16] 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 ## [31] 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 ## [46] 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 ## [61] 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 1989 Again, let’s use mutate to assign this as a new column weather &lt;- mutate(weather, year = year(Date)) 4.2.1 Check in challenge We are going to review our basic wrangling skills to prepare the Palmer Station weather data to merge with the penguins data. We would like to merge a summary of the weather data with the penguins. For this summary, we want the data summarized by year, rather than by day (as it currently is). Then per year, we want to know the maximum, minimum, and average temperates. Create this summary table called ‘weather_summary’. Check your answer weather_summary &lt;- weather %&gt;% group_by(year) %&gt;% summarize(average_temp = mean(Temperature.Average..C., na.rm = T), max_temp = max(Temperature.High..C., na.rm = T), min_temp = min(Temperature.Low..C., na.rm = T)) 4.3 Joining multiple data frames THIS IS WHERE I LEFT OFF _join series: Combine two data frames by one or more shared columns. Specify with kind of join(full_, left_, etc.) to determine which observations are kept/dropped. penguins_leftjoined &lt;- left_join(penguins, weather_summary, by = &quot;year&quot;) dim(penguins_leftjoined) ## [1] 344 11 4.3.1 Check in challenge What happens when you use another kind of join? penguins_fulljoined &lt;- full_join(penguins, weather_summary, by = &quot;year&quot;) # We now have more rows for dim(penguins_fulljoined) ## [1] 372 11 4.3.2 Reshaping (lengthening/widening) data pivot_longer pivot_wider Pivot the data to make it wider, with one row per species and the columns representing the mean bill length, depth, and mass for that species. # Pivot the data to make it longer penguins_longer &lt;- pivot_longer(penguins, cols = c(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g), names_to = &quot;measure&quot;, values_to = &quot;value&quot;) # Pivot the data to make it wider, with one row per species and the columns representing the mean bill length, depth, and mass for that species. penguins_wider &lt;- penguins %&gt;% group_by(species) %&gt;% summarize(mean_bill_length_mm = mean(bill_length_mm), mean_bill_depth_mm = mean(bill_depth_mm), mean_body_mass_g = mean(body_mass_g)) penguins_wider &lt;- pivot_wider(penguins_wider, names_from = &quot;species&quot;, values_from = c(&quot;mean_bill_length_mm&quot;, &quot;mean_bill_depth_mm&quot;, &quot;mean_body_mass_g&quot;)) 4.4 Working with text separate: paste: # Load the Palmer Penguins dataset (with additional missing values) penguins_raw ## # A tibble: 344 × 17 ## studyName Sample Num…¹ Species Region Island Stage Indiv…² Clutc…³ `Date Egg` ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; ## 1 PAL0708 1 Adelie… Anvers Torge… Adul… N1A1 Yes 2007-11-11 ## 2 PAL0708 2 Adelie… Anvers Torge… Adul… N1A2 Yes 2007-11-11 ## 3 PAL0708 3 Adelie… Anvers Torge… Adul… N2A1 Yes 2007-11-16 ## 4 PAL0708 4 Adelie… Anvers Torge… Adul… N2A2 Yes 2007-11-16 ## 5 PAL0708 5 Adelie… Anvers Torge… Adul… N3A1 Yes 2007-11-16 ## 6 PAL0708 6 Adelie… Anvers Torge… Adul… N3A2 Yes 2007-11-16 ## 7 PAL0708 7 Adelie… Anvers Torge… Adul… N4A1 No 2007-11-15 ## 8 PAL0708 8 Adelie… Anvers Torge… Adul… N4A2 No 2007-11-15 ## 9 PAL0708 9 Adelie… Anvers Torge… Adul… N5A1 Yes 2007-11-09 ## 10 PAL0708 10 Adelie… Anvers Torge… Adul… N5A2 Yes 2007-11-09 ## # … with 334 more rows, 8 more variables: `Culmen Length (mm)` &lt;dbl&gt;, ## # `Culmen Depth (mm)` &lt;dbl&gt;, `Flipper Length (mm)` &lt;dbl&gt;, ## # `Body Mass (g)` &lt;dbl&gt;, Sex &lt;chr&gt;, `Delta 15 N (o/oo)` &lt;dbl&gt;, ## # `Delta 13 C (o/oo)` &lt;dbl&gt;, Comments &lt;chr&gt;, and abbreviated variable names ## # ¹​`Sample Number`, ²​`Individual ID`, ³​`Clutch Completion` "],["visualization.html", "5 Visualization 5.1 Outline 5.2 Plot architecture 5.3 Selecting geometries 5.4 Challenge 5.5 Styling (automatic and manual)", " 5 Visualization 5.1 Outline Plot architecture ggplot aes geom_ Selecting geometries geom_point geom_bar and geom_col geom_boxplot geom_line Styling (automatic and manual) labs theme_ scale_ Facets 5.2 Plot architecture Create a scatterplot of bill length and body mass ggplot(penguins, aes(x = bill_length_mm, y = body_mass_g)) + geom_point() ## Warning: Removed 2 rows containing missing values (`geom_point()`). ggplot(penguins, aes(x = bill_length_mm, y = body_mass_g, color = species)) + geom_point() ## Warning: Removed 2 rows containing missing values (`geom_point()`). 5.3 Selecting geometries ggplot(penguins, aes(x = bill_length_mm, y = body_mass_g, color = species)) + geom_point() + geom_smooth(method = &#39;lm&#39;) ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## Warning: Removed 2 rows containing non-finite values (`stat_smooth()`). ## Warning: Removed 2 rows containing missing values (`geom_point()`). Create a barplot of species counts ggplot(penguins, aes(x = species)) + geom_bar() ggplot(penguins, aes(x = species, y = flipper_length_mm)) + geom_boxplot() ## Warning: Removed 2 rows containing non-finite values (`stat_boxplot()`). weather %&gt;% ggplot(aes(x = Date, y = Temperature.Average..C.)) + geom_line() weather %&gt;% ungroup() %&gt;% filter(year != min(year) &amp; year != max(year)) %&gt;% ggplot(aes(x = year, y = Temperature.Average..C., group = year)) + geom_boxplot() ## Warning: Removed 11 rows containing non-finite values (`stat_boxplot()`). 5.4 Challenge Conditional statements weather &lt;- weather %&gt;% mutate(penguin_data_year = case_when( year %in% 2007:2009 ~ T, T ~ F ) ) weather %&gt;% filter(year != min(year) &amp; year != max(year)) %&gt;% ggplot(aes(x = year, y = Temperature.Average..C., group = year, color = penguin_data_year)) + geom_boxplot() ## Warning: Removed 11 rows containing non-finite values (`stat_boxplot()`). ggplot(penguins, aes(x = bill_length_mm, y = body_mass_g)) + geom_point() + facet_wrap(~ species) ## Warning: Removed 2 rows containing missing values (`geom_point()`). 5.5 Styling (automatic and manual) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
